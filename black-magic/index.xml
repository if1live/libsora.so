<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Black-magics on /usr/lib/libsora.so</title>
    <link>https://libsora.so/black-magic/</link>
    <description>Recent content in Black-magics on /usr/lib/libsora.so</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 11 Jul 2020 00:00:00 +0900</lastBuildDate><atom:link href="https://libsora.so/black-magic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>express에서 콘솔로 찍은 로그를 HTTP 응답에 붙이기</title>
      <link>https://libsora.so/posts/express-attach-console-log-to-response/</link>
      <pubDate>Sat, 11 Jul 2020 00:00:00 +0900</pubDate>
      
      <guid>https://libsora.so/posts/express-attach-console-log-to-response/</guid>
      <description>HTTP 응답에 콘솔 로그 붙인 이유 간단한 express 서버가 있다고 치자.
const express = require(&#39;express&#39;); const delay = require(&#39;delay&#39;); const app = express(); app.get(&#39;/&#39;, async (req, res) =&amp;gt; { const data = await execute(req.query || {}); res.json(data); }); async function execute(input) { const id = input.id; console.info(`before delay: ${id}`); await delay(100); console.warn(`after delay: ${id}`); return { id }; } const port = 3000; app.listen(port, () =&amp;gt; console.log(`listen: 127.0.0.1:${port}`));  http://127.0.0.1:3000/?id=1로 접속하면 아래와 같은 JSON을 응답으로 받는다.</description>
    </item>
    
    <item>
      <title>typeorm에서 repository.save() 호출할때 UPDATE 쿼리만 사용하기</title>
      <link>https://libsora.so/posts/typeorm-entity-proxy-for-save/</link>
      <pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/typeorm-entity-proxy-for-save/</guid>
      <description>repository.save() 의 함정 typeorm으로 아래와 같은 엔티티를 정의했다고 치자.
@Entity() export class UserEntity { @PrimaryColumn() key1: string; @PrimaryColumn() key2: string; @Column() data: string; }  엔티티를 살짝 고쳐서 저장하자.repository.save()를 이용하면 쉽게 저장할 수 있다. (BEGIN TRANSACTION, COMMIT이 쿼리에 들어가는걸 없애려고 transaction을 껏다)
const repo = conn.manager.getRepository(UserEntity); user.data = &#39;save&#39;; await repo.save(user, { transaction: false });  데이터 저장하는건 1줄인데 실행되는 SQL은 1개가 아니다.
query: SELECT &amp;quot;UserEntity&amp;quot;.&amp;quot;key1&amp;quot; AS &amp;quot;UserEntity_key1&amp;quot;, &amp;quot;UserEntity&amp;quot;.&amp;quot;key2&amp;quot; AS &amp;quot;UserEntity_key2&amp;quot;, &amp;quot;UserEntity&amp;quot;.</description>
    </item>
    
    <item>
      <title>ioredis에 로깅 끼워넣기</title>
      <link>https://libsora.so/posts/ioredis-logging-with-monkey-patch/</link>
      <pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/ioredis-logging-with-monkey-patch/</guid>
      <description>로깅의 필요성 요새 작업하고 있는 프로젝트에서 typeorm과 ioredis를 쓰고 있다. 기능이 검증된 코드를 짜기 위해서 유닛 테스트를 도배하고 있다. 하지만 유닛 테스트로는 성능을 확인할 순 없다. redis MSET 한번으로 될 일을 SET 100번 호출하고 있더라도 유닛테스트는 통과할 것이다.
최적화라는 빅-픽쳐를 위해 서버가 redis, rdbms로 요청 보낼때 로그를 남기기로 했다. 지정된 규격으로 로그를 찍으면 CloudWatch Logs를 통해서 elasticsearch에 저장되도록 만들고 싶다.
typeorm: custom logger typeorm은 로깅 갈아끼우는걸 기본적으로 지원한다. custom logger를 쓰면 된다고 한다.</description>
    </item>
    
    <item>
      <title>최상위 비트의 위치 찾는 방법</title>
      <link>https://libsora.so/posts/find-the-highest-order-bit/</link>
      <pubDate>Sun, 26 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/find-the-highest-order-bit/</guid>
      <description>개요 이전에 나머지 연산자 없이 x % 256 계산하기과 나머지 연산자 없이 x % (2의 거듭제곱) 계산하기라는 글을 썻다. 색다른 기법을 다루는 글인척 하지만 컴파일러가 이미 그렇게 동작하기때문에 니가 하는 최적화는 뻘짓이라는걸 보여주는 목적의 글이었다. 여기에서 글이 끝나면 재미없다. 위의 글을 통해 배운 기법을 이용해서 조금 더 쓸모있어 보이는 (하지만 실제로는 쓸모없는) 코드를 짜보자.
최상위 비트의 위치 찾기 1 -&amp;gt; 0001 -&amp;gt; 0 2 -&amp;gt; 0010 -&amp;gt; 1 3 -&amp;gt; 0011 -&amp;gt; 1 4 -&amp;gt; 0100 -&amp;gt; 2 .</description>
    </item>
    
    <item>
      <title>나머지 연산자 없이 x % (2의 거듭제곱) 계산하기</title>
      <link>https://libsora.so/posts/use-bit-op-as-mod-operator/</link>
      <pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/use-bit-op-as-mod-operator/</guid>
      <description>이전에 나머지 연산자 없이 x % 256 계산하기라는 글을 썻다. % 256만 계산할 수 있으면 재미없으니까 더 확장해보자.
% 256을 구하기 위해서 캐스팅을 이용했다. 4바이트 정수를 1바이트 정수로 캐스팅해서 하위 1바이트만 남겼다. 이를 바꿔말하면 256진법의 4자리수에서 마지막 한자리만 남겼다고 표현할 수 있다. 1234를 100으로 나누는 것을 생각해보자. 진짜로 100으로 나누는 사람이 있나 모르겠다. 백의 자리에서 숫자를 자르면 같은 값을 얻을 수 있고 더 빠르게 계산 가능하다.
256진법, 10진법말고 2진법에도 이것을 적용하자.</description>
    </item>
    
    <item>
      <title>나머지 연산자 없이 x % 256 계산하기</title>
      <link>https://libsora.so/posts/use-casting-as-mod-operator/</link>
      <pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/use-casting-as-mod-operator/</guid>
      <description>1년전, 2017년 8월 16일에 재밌는 생각이 나서 트윗을 쓴게 있다.
a%256 최적화 하기 : (int)(unsigned char)a clang 기준 -O3 옵션 주면 어셈 한줄 https://twitter.com/if1live/status/897752172040929280  C에서 타입 캐스팅을 캐스팅 연산자라고 부르니까 이걸 다른 연산자로 쓰는게 가능하지 않을까? 그런 생각이 들어서 짜본 코드다.
그럴싸하게 정리해보려다가 귀찮아서 미룬걸 1년만에 해본다.
구현 https://ideone.com/ZvMaRZ
#include &amp;lt;assert.h&amp;gt; int mod_256(int x) { return (int)(unsigned char)x; } int main() { assert(mod_256(257) == 257 % 256); return 0; }  아이디어는 간단하다.</description>
    </item>
    
    <item>
      <title>오늘은 3, 1, 4, 2로 10을 만들어 봅시다!</title>
      <link>https://libsora.so/posts/make-10-with-overflow/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/make-10-with-overflow/</guid>
      <description>개요 2017년에 트위터에 #10을만들자 라는 해시태그가 유행한적 있다.
이런 느낌의 트윗이다.
 오늘은 3, 1, 4, 2로 10을 만들어 봅시다! 존재하는 모든 연산을 허용합니다. 단, 숫자 붙이기(ex. 1과 5를 붙여 15를 만드는 것 등)는 허용하지 않습니다. 각 숫자는 한 번씩만 사용합시다. 0722 #10을만들자 https://twitter.com/MathQ_kr/status/888413492465639425
 며칠동안 지속된 해시였고 며칠동안 재밌는 풀이를 만들기 위해서 고민했었다. 나의 풀이법 중에 가장 기억에 남는걸 뒤늦게라도 정리해보았다.
오늘은 3, 1, 4, 2로 10을 만들어 봅시다! https://twitter.</description>
    </item>
    
    <item>
      <title>나눗셈 연산을 곱셈으로 프로그래밍 할 수 있음?</title>
      <link>https://libsora.so/posts/float-divide-without-divide/</link>
      <pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/float-divide-without-divide/</guid>
      <description>개요 몇달전에 SNS를 하다가 재밌는 글을 봤다.
 나눗셈 연산을 곱셈으로 프로그래밍 할 수 있음?
나누기/ 연산자를 안쓰고
 정수에 대해서는 어떻게 구현할지 잘 모르겠지만 부동소수에서 간단한 방법이 보이더라. Fast inverse square root를 쓰면 될거같다.
고속 역 제곱근은 $\frac{1}{\sqrt{x}}$를 구하는 함수이다. 이것을 제곱하면 $\frac{1}{x}$가 된다. /x나 *(1/x)나 똑같은거니까 문제는 다 푼것과 마찬가지다.
코드를 공유할때는 ideone같은게 편하더라. 그래서 코드를 넣고 돌렸다. 그리고 재밌는 결과가 나오기 시작하는데&amp;hellip;.
code #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;math.h&amp;gt; // https://en.</description>
    </item>
    
    <item>
      <title>나도 해보는 Fizz Buzz Test</title>
      <link>https://libsora.so/posts/fizz-buzz-01/</link>
      <pubDate>Sat, 04 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/fizz-buzz-01/</guid>
      <description>Fizz Buzz Test? Fizz Buzz Test는 상당히 오래된 떡밥이다.
 Write a program that prints the numbers from 1 to 100. But for multiples of three print &amp;ldquo;Fizz&amp;rdquo; instead of the number and for the multiples of five print &amp;ldquo;Buzz&amp;rdquo;. For numbers which are multiples of both three and five print &amp;ldquo;FizzBuzz&amp;rdquo;.
  우리 말로 풀어서 쓰면, 1부터 100사이의 숫자를 프린트하는 프로그램을 작성하는데 3의 배수이면 &amp;ldquo;Fizz&amp;quot;를, 5의 배수이면 &amp;ldquo;Buzz&amp;quot;를, 둘 모두의 배수 즉 15의 배수이면 &amp;ldquo;FizzBuzz&amp;rdquo; 를 프린트하도록 하라.</description>
    </item>
    
    <item>
      <title>int main() { #include &#34;data.txt&#34; return 0; }</title>
      <link>https://libsora.so/posts/x-macro-is-useful/</link>
      <pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/x-macro-is-useful/</guid>
      <description>흑마법은 많이 짜봤지만
int foo() { #include &amp;ldquo;data.txt&amp;rdquo; }
를 이길 물건은 아직 짜지 못했다. 내 명작 흑마법이었는데 리펙토링 하려다 c++ 접어서 방치
 트위터에서 남들의 흑마법 코드를 보다가 5년전에 짠 흑마법 코드가 생각나서 글을 써본다. C, C++ 많이 해본 사람은 다 알고있을 뻔한 주제다. 하지만 처음하는 사람은 글을 읽고 include, define에 대한 새로운 관점을 배울 수 있을거다.
다시 보는 include C컴파일러는 하나의 소스만 읽고 컴파일할 수 있다. 근데 우리는 stdio.</description>
    </item>
    
    <item>
      <title>반복문, 재귀없이 터미널에 다이아 그리기</title>
      <link>https://libsora.so/posts/double-loop-with-array/</link>
      <pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/double-loop-with-array/</guid>
      <description>간단한 문제 극악의 c언어 문제
----- * *** ***** *** * ----- for문을 이용해서 별을 출력하는 문제인데 주변에 프로그래밍좀 한다는 친구들도 이 문제는 못풀더군요. 과연 오유 여러분의 실력은 어느정도 될런지..  delete this 이용해서 터미널에 삼각형 그리기를 쓰다 예전에 봤던 문제를 다시 꺼내봤다. 그리고 이 문제를 반복문, 재귀호출 없이 풀었던게 생각나서 다시 풀어봤다.
step 1. 반복문 1개로 삼각형 출력하기 * *** *****  다이아의 위쪽을 먼저 그러보자. *****를 루프없이 그리는 여러가지 방법이 있지만 가장 간단한 std::string의 생성자를 이용했다.</description>
    </item>
    
    <item>
      <title>delete this 이용해서 터미널에 삼각형 그리기</title>
      <link>https://libsora.so/posts/recursion-with-destructor/</link>
      <pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/recursion-with-destructor/</guid>
      <description>어제 회사에서 delete this 에 대해 이것저것 이야기를 했었다. 그리고 꿈에서 delete this 로 재귀를 구현하는 흑마법이 생각나서 짜봤다.
 목표 : delete this를 이용해서 다음과 같은 삼각형을 출력해야한다.  for, while 같은 키워드 사용 금지 명시적인 재귀호출 없음, 단 delete this는 허용    * ** ***  기본 구현 delete를 쓰면 메모리를 해제하고 소멸자를 호출한다. 그렇다면 소멸자 안에서 delete this를 사용하면 자기 자신의 소멸자를 다시 호출할테니 재귀호출이 되는거 아니냐?</description>
    </item>
    
  </channel>
</rss>
