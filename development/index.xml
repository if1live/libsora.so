<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Developments on /usr/lib/libsora.so</title>
    <link>https://libsora.so/development/</link>
    <description>Recent content in Developments on /usr/lib/libsora.so</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 09 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://libsora.so/development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>자바스크립트에서 expect(-3 % 3).toEqual(3 % 3)가 실패하는 이유</title>
      <link>https://libsora.so/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</link>
      <pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</guid>
      <description>-3%3 과 3%3은 같은가? 얼마전에 코딩하다 밟은 버그에 대해서 이야기를 해본다.
자바스크립트로 미디어 플레이어의 플레이리스트를 구현하고 있었다. 플레이리스트는 간단히 배열로 구현했다.
const item = playlistItems[cursor];  만약 플레이리스트의 크기가 3이고, cursor가 2인 경우 다음곡을 누르는 경우를 생각하자. 2에 1을 더한 후 3을 cursor로 배열에 그대로 접근하면 out of index 에러가 발생할것이다. (배열의 크기가 3이면 가능한 인덱스는 0~2이니까)
cursor를 index로 바꿔주는 적절한 함수가 있다고 치자. 이것이 음수, 양수 범위에서 동작할거라고 가정하자. cursor를 대충 건드려도 적당히 굴러갈것이다.</description>
    </item>
    
    <item>
      <title>타입스크립트에서 if문 안에 promise가 들어가는 문제 피하기</title>
      <link>https://libsora.so/posts/prevent-bug-by-if-statement-with-promise/</link>
      <pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/prevent-bug-by-if-statement-with-promise/</guid>
      <description>async function + if 옛날 옛적 미개한 자바스크립트에는 콜백뿐이었다. 나중에 promise가 추가되서 좋아졌다. 더 나중에 async/await가 추가되서 더 좋아졌다. async/await 좋다고 열심히 쓰다가 이번주에 아래와 같은 함정을 밟았다.
export const isReady = async () =&amp;gt; { const timeout = new Promise((resolve) =&amp;gt; { setTimeout(resolve, 100) }); await timeout; return false; };  common.ts에 있는 isReady()는 async 함수이다. 예제 코드니까 적당한 시간 뒤에 false를 반환하도록 구현했다.
import { isReady } from &#39;.</description>
    </item>
    
    <item>
      <title>-4 % 3 = ?</title>
      <link>https://libsora.so/posts/sign-of-mod-operator/</link>
      <pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/sign-of-mod-operator/</guid>
      <description>% 연산자를 응용해보는 글을 쓰기전에 % 연산자에 대해서 간단하기 글을 써보기로 했다. % 는 나머지 연산자로4 % 3 을 계산하면 1이 나온다는건 다들 알고있을거다.
그렇다면 -4 % 3, 4 % -3의 결과는?
python Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:06:47) [MSC v.1914 32 bit (Intel)] on win32 Type &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license()&amp;quot; for more information. &amp;gt;&amp;gt;&amp;gt; -4 % 3 2 &amp;gt;&amp;gt;&amp;gt; 4 % -3 -2   -4 % 3 = 2 4 % -3 = -2  javascript &amp;gt; -4 % 3 &amp;lt; -1 &amp;gt; 4 % -3 &amp;lt; 1   -4 % 3 = -1 4 % -3 = 1  note 파이썬과 자바스크립트에서 결과가 다르다.</description>
    </item>
    
    <item>
      <title>윈도우에서 심볼릭 링크 만들기</title>
      <link>https://libsora.so/posts/ntfs-symbolic-link/</link>
      <pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/ntfs-symbolic-link/</guid>
      <description>왜 윈도우에서 심볼릭 링크를 만드나? 옛날 옛적에는 컴퓨터를 하다가 상태가 안좋아진거 같으면 포맷을 했다. 파티션을 C, D 드라이브로 분리하고 포맷을 해도 유지되어야 하는 데이터는 D 드라이브에 넣었다. 그리고 C 드라이브를 포맷하고 윈도우를 재설치했다. 겉보기에는 간단한 작업이지만 백업하는걸 잊어버리고 잃어버리는 일이 자주 생겼다. 대표적인 예가 게임 세이브 파일이었다. 그래서 게임 세이브 파일을 안전하게 백업할수 있는 방법을 옛날부터 생각해봤다.
2014년쯤, 답을 찾았다. 게임 세이브 파일을 github에 통째로 올리면 되겠더라. 당시에도 스팀 클라우드로 세이브 파일을 저장하는 기능이 있긴했다.</description>
    </item>
    
    <item>
      <title>go get {command-line-tool} FAILED</title>
      <link>https://libsora.so/posts/golang-hugo-is-down/</link>
      <pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/golang-hugo-is-down/</guid>
      <description>go get -u github.com/gohugoio/hugo : FAIL 2018년 3월 9일, 블로그 빌드 스크립트 개선 작업을 했다. 별것도 고치지 않고 푸시했는데 travis-ci에서 빌드 도중 문제가 발생했다.
 2018년 3월 8일까지는 멀쩡하게 빌드가 됐었다.  travis-ci build log   2018년 3월 9일 밤에 빌드를 시도한건 실패했다.  travis-ci build log    실패 기록을 뜯어보고 이유를 찾았다.
$ go get -u github.com/gohugoio/hugo # github.com/gohugoio/hugo/output ../../gohugoio/hugo/output/docshelper.go:4:2: imported and not used: &amp;quot;fmt&amp;quot;  golang은 사용하지 않는 import가 있으면 컴파일 에러로 취급한다.</description>
    </item>
    
    <item>
      <title>100 * 0.7 = ?</title>
      <link>https://libsora.so/posts/amazing-floating-point-100x07/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/amazing-floating-point-100x07/</guid>
      <description>100 * 0.7 = 69 Toy Clash는 10단계로 조절할 수 있는 막대 그래프를 이용해서 BGM 조절을 구현했다.
옵션을 저장하는 방식으로는 디버깅이 편한 XML을 사용했다.
&amp;lt;volume-bgm&amp;gt;70&amp;lt;/volume-bgm&amp;gt;  30%라는 값을 표현할때 &amp;lt;volume-bgm&amp;gt;0.30000000000000004&amp;lt;/volume-bgm&amp;gt;이라고 표현되는 것보다 &amp;lt;volume-bgm&amp;gt;30&amp;lt;/volume-bgm&amp;gt;이라고 표현되는게 깔끔하니 정수로 볼륨값을 표현했다. 볼륨의 최대값은 100으로 설정하고 기본값으로 70%로 설정했다. 설정파일에서는 볼륨이 70이라고 기록되고 옵션 메뉴에서는 막대가 7개면 올바르게 구현되었다고 말할수 있을것이다.
그런데 실제로 구현하고나니 BGM 볼륨 막대가 6개더라. 옵션 파일을 열어보니 볼륨값이 69로 기록되어 있엇다.</description>
    </item>
    
    <item>
      <title>GC없이 C# Dictionary에서 enum을 key로 쓰기</title>
      <link>https://libsora.so/posts/csharp-dictionary-enum-key-without-gc/</link>
      <pubDate>Sun, 20 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/csharp-dictionary-enum-key-without-gc/</guid>
      <description>C# Dictionary + enum C# Dictionary는 Key-Value로 데이터를 저장할수 있는 좋은 자료구조이다. enum은 key로 쓰기에 좋은 타입이다. 그렇다면 둘을 합쳐보자.
적당한 클래스와 enum을 준비한다.
﻿interface IState { string GetMessage(); } class State_Wait : IState { public string GetMessage() { return &amp;quot;wait&amp;quot;; } } class State_Run : IState { public string GetMessage() { return &amp;quot;run&amp;quot;; } } enum States { Wait, Run, }  Dictionary을 만들고 데이터를 저장해두자. Update()에서 Dictionary에 접근해보자. Dictionary를 쓰면 자주 사용할 기능 두 개를 사용했다.</description>
    </item>
    
    <item>
      <title>C#에서 GC없이 enum을 int로 변환하기</title>
      <link>https://libsora.so/posts/csharp-enum-to-int/</link>
      <pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/csharp-enum-to-int/</guid>
      <description>시나리오: enum으로 상태 관리 간단한 예제를 생각해보자. IState를 구현한 클래스가 있다고 가정하자. 그리고 클래스를 enum으로 관리하려고한다. IState를 구현한 클래스가 몇개로 늘어날지 모르니 배열을 사용했다.
﻿interface IState { string GetMessage(); } class State_Wait : IState { public string GetMessage() { return &amp;quot;wait&amp;quot;; } } class State_Run : IState { public string GetMessage() { return &amp;quot;run&amp;quot;; } } enum States { Wait, Run, }  ﻿using UnityEngine; class Main_SimpleArray : MonoBehaviour { IState[] states; private void Start() { states = new IState[2]; states[(int)States.</description>
    </item>
    
    <item>
      <title>윈도우에서 길고 아름다운 경로명을 사용하는 방법</title>
      <link>https://libsora.so/posts/dispatch-by-prefix/</link>
      <pubDate>Sun, 05 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/dispatch-by-prefix/</guid>
      <description>MAX_PATH 윈도우는 경로 최대길이가 제한되어 있다. MAX_PATH라는 상수로 260이다. 그래서 매우 긴 디렉토리를 만든 다음에 안에서 파일을 만들라고하면 다음과 같은 문제가 발생한다.
지금이 90년대 컴퓨터도 아니고 고작 260글자까지밖에 지원하지 않는다고? MAX_PATH가 260라니 윈도우에 실망했습니다. 윈도우 팬 그만둡니다.
로 끝내면 재미없다. MSDN을 읽어보자.
MSDN  Maximum Path Length Limitation
In the Windows API (with some exceptions discussed in the following paragraphs), the maximum length for a path is MAX_PATH, which is defined as 260 characters.</description>
    </item>
    
    <item>
      <title>Noto Sans Thai 올바르게 렌더링하는 방법</title>
      <link>https://libsora.so/posts/how-to-render-noto-sans-thai-correctly/</link>
      <pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/how-to-render-noto-sans-thai-correctly/</guid>
      <description>개요 cocos2d-x 2.x 기반으로 개발된 모바일 게임을 태국에서 서비스하는 일을 예전에 했었다. (게임의 기본 폰트는 Noto Sans Thai였다) 개발하면서 크고 작은 태국어 렌더링 버그를 겪었고 대부분의 문제는 어떻게든 해결했다. 하지만 어떤 편법을 써도 제대로 렌더링하지 못했던 문자열이 있었다.
 ร่ำ นายนี่ไม่ได้เปลี่รํ่า
 (뜻도 모른다. 렌더링 제대로 안되는 글자를 모아문 문자열이다)
이 문자열을 크롬하고 똑같이 보이게 하기 위해서 삽질했던 기록을 정리했다.
주의  태국어 폰트에 대한 설명은 다루지 않는다. 나도 태국어 폰트 구조를 모른다 Noto Sans Thai만 취급한다.</description>
    </item>
    
    <item>
      <title>golang 패키지 관리의 약점과 대응책</title>
      <link>https://libsora.so/posts/golang-package-management-failure-learned-from-github-kr-text/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/golang-package-management-failure-learned-from-github-kr-text/</guid>
      <description>개요 2016년 3월 22일, npm에서 left-pad가 사라지면서 node.js를 사용하는 수많은 사람들이 혼돈의 카오스에 빠졌다. 그리고 2016년 5월 5일, hugo를 쓰던 나도 비슷한 경험을 했다. 그날, hugo에서는 어떤 문제가 있었는지를 살펴봄으로써 golang 패키지 관리 기법의 문제점을 이해하고 golang은 어떤식의 해결책을 제시했는지 정리해보았다.
github.com/kr/text 사태 (가칭) 문제 발생 2016/05/05 00:48 +0900 : 정상 hugo에 의존하는 블로그 빌드가 정상적으로 작동했다. 특별한 문제는 없다
2016/05/05 15:34 +0900 : 빌드 실패! hugo에 의존하는 블로그 빌드가 깨졌다.</description>
    </item>
    
    <item>
      <title>버그 삽질기 - 파이썬으로 구현한 API 서버 루비로 포팅하기</title>
      <link>https://libsora.so/posts/http-request-params-trap-python-and-ruby/</link>
      <pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/http-request-params-trap-python-and-ruby/</guid>
      <description>간단한 명언 API 서버를 만들보자. 필요한 기능은 다음과 같다.
 명언 목록을 데이터로 분리한다. 나중에 목록을 쉽게 갱신할수 있어야한다. 서버에 접속하면 명언중 하나를 임의로 골라서 보여준다. Query String을 이용해서 특정 명언을 골라서 볼수 있어야 한다. (결정론적으로 작동해야 테스트하기 쉬우니까) Query String이 올바르지 않으면 임의로 하나를 보여준다.  다은은 간단한 작성된 명언 목록이다. 한줄에 하나의 명언을 적었다.
가정이 무너지고 사회가 무너지고 안 되겠소 쏩시다 트위터는 인생의 낭비 비둘기야 먹자 애니메이션 캐릭터에 꼴린다면 정신병원에 가보세요 인간의 욕심은 끝이 없고 같은 실수를 반복한다  마이크로 프레임워크 중 하나인 flask로 간단한 API 서버를 만들었다.</description>
    </item>
    
    <item>
      <title>존재하지 않는 키로 테이블에 접근하면?</title>
      <link>https://libsora.so/posts/if-key-does-not-exist-then/</link>
      <pubDate>Thu, 25 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/if-key-does-not-exist-then/</guid>
      <description>존재하지 않은 키로 테이블에 접근했을때 각각의 언어는 어떤 식으로 행동할까? 올바르지 않은 인덱스로 리스트에 접근하면 각각의 언어는 어떤 식으로 행동할까? 파이썬, 루비, C++를 통해서 알아보자.
파이썬 파이썬은 C와 달리 음수 인덱스를 지원한다. -len(array) ~ len(array)-1 까지는 올바른 인덱스이다. 음수 인덱스를 쓰면 배열을 뒤에서부터 접근할 수 있다.
만약 파이썬의 리스트에 허용 범위를 벗어난 인덱스로 접근하면 어떤 일이 벌어질까? 존재하지 않는 키로 파이썬의 사전에 접근하면 어떤 일이 벌어질까?
foo_list = [1, 2, 3] try: print(foo_list[100]) except Exception as ex: print(repr(ex)) foo_dict = {&amp;quot;foo&amp;quot;: 2, &amp;quot;bar&amp;quot;: 4} try: print(foo_dict[&amp;quot;spam&amp;quot;]) except Exception as ex: print(repr(ex))  $ python .</description>
    </item>
    
    <item>
      <title>올바르지 않은 값을 정수로 변환하기 - 파이썬 vs 루비</title>
      <link>https://libsora.so/posts/make-int-from-invalid-value-python-and-ruby/</link>
      <pubDate>Wed, 24 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/make-int-from-invalid-value-python-and-ruby/</guid>
      <description>올바르지 않은 값을 정수로 바꾸는 일은 웹을 포함한 여러가지 개발에서 자주하는 작업 중 하나이다. 예를 들어서 /articles/?id={int} 를 구현한 서버가 있다고 가정하자. /articles/?id=1234와 같이 id에 정수 문자열이 들어갈수도 있다. 하지만 /articles/?id=test와 같이 숫자가 아닌 문자열이 들어갈수도 있고 /articles/처럼 id가 없을수도 있다. 개발자는 이런 예외 상황을 잘 처리해야된다.
이 글에서는 파이썬과 루비에서 문자열을 숫자로 변환할때의 차이점을 간단하게 정리했다.
String to int Success &amp;quot;123&amp;quot;과 같이 딱봐도 정수처럼 보이는 문자열을 정수로 바꿔보았다.
print(int(&amp;quot;123&amp;quot;))  $ python str_to_int_success.</description>
    </item>
    
    <item>
      <title>삽질로 알아보는 파이썬과 루비의 기본 매개변수</title>
      <link>https://libsora.so/posts/default-argument-python-and-ruby/</link>
      <pubDate>Thu, 18 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/default-argument-python-and-ruby/</guid>
      <description>파이썬과 루비의 문법 차이로 인한 버그를 당한적은 자주 있었지만 글로 다룰 생각까진 (게을러서) 하지 않았다. 하지만 아래의 글을 읽고 파이썬와 루비의 차이로 인한 버그를 정리해보면 재밌을거라고 생각했다. 그래서 써보기로 했다.
루비와 파이썬에서 함수 호출과 함수 참조에 대한 차이
기본 매개변수를 이용해서 낚시를 해보자. (얼마나 낚일지는 모르지만) Default argument 를 남들이 기본 매개변수라고 번역하길래 기본 매개변수라고 적었지만 디폴트 매개변수, 기본 인자 등등으로도 불리는거같다. 용어를 하나로 합치려고 default argument 만을 사용하겠다.
문제1. 다음 코드의 실행 결과는?</description>
    </item>
    
    <item>
      <title>예제로 보는 Python과 Ruby의 문법 차이 - Multiple Assignment</title>
      <link>https://libsora.so/posts/multiple-assignment-python-and-ruby/</link>
      <pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/multiple-assignment-python-and-ruby/</guid>
      <description>파이썬과 루비는 겉보기에는 비슷해보이면서 완전히 다르게 행동하는 문법이 있다. 그래서 파이썬을 생각하면서 루비 코드를 짜면 어처구니 없는 버그가 생긴다. 이런 일을 방지하고자 지금까지 당해본 파이썬과 루비의 문법 차이를 정리하려고 한다. 오늘은 Multiple Assignment이다. (여러 개의 변수에 값을 동시에 할당하기)
Python 2.x 변수 1개에 정수를 1개 할당하는 것부터 시작하자. 매우 기본적인 문법이다.
source: a = 1 a=1  변수 2개에 정수를 2개 할당하면 어떻게 될까? 1, 2 이라고 썻기때문에 값이 2개인 것처럼 보이지만 사실 파이썬에서는 (1, 2) 같이 튜플로 묶어서 처리한다.</description>
    </item>
    
    <item>
      <title>Go language 첫인상</title>
      <link>https://libsora.so/posts/golang-first-impression/</link>
      <pubDate>Sun, 20 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/golang-first-impression/</guid>
      <description>개요 주력 언어를 바꾸는건 어려운 일이다. 주력 언어를 바꾸면 상당히 많은걸 버려야하기 때문이다. 익숙한 세계를 버리고, 지금까지 배운 라이브러리를 잊고, 지금까지 배운 상식까지 버려야할 수도 있다.
그럼에도 불구하고 현재의 주력 언어인 파이썬, 루비, C++를 버리고 다른 언어로 갈아타기로 했다. 기존의 주력 언어에 남아서 어떻게든 문제를 해결하려고 삽질하는 것보다 내가 지금 처한 문제가 해결되어있는 새로운 언어로 갈아타서 다시 공부하는게 빠르겠더라.
다음 주력 언어로는 Go language를 찍었다. 결정한 이유는 크게 3가지이다.
첫번째 이유는 옆애 erlang, Go language를 찬양하는 아저씨가 옆에 있어서다.</description>
    </item>
    
    <item>
      <title>매크로 상수를 변경하기 쉽게 바꾸는 편법</title>
      <link>https://libsora.so/posts/refactoring-c-macro-constant/</link>
      <pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/refactoring-c-macro-constant/</guid>
      <description>int main() { printf(&amp;quot;%d\n&amp;quot;, FOO + 123);  프로젝트를 진행하면 아무리 설계를 잘해도 여러 파일에서 사용되는 상수를 피할수 없다. 이때는 보통 공유하는 상수/함수 등을 모아서 별도의 헤더 파일을 만들어서 관리한다.
 Quake2/game/g_local.h DOOM3-BFG/doomclassic/doom/defs.h  예를 들어 위의 코드에서는 FOO 이 상수이다. 그리고 간단하게 매크로를 이용해서 상수를 구현했다.
#define FOO 321  작은 규모에서는 이런식으로 상수를 사용해도 별 문제가 없다. 하지만 프로젝트가 커지면 심각한 문제가 생긴다.
예를 들어 현재 작업하고 있는 프로젝트를 전체 다시 빌드하면 10분 걸린다고 가정하자.</description>
    </item>
    
    <item>
      <title>아름다운 PHP array_search()</title>
      <link>https://libsora.so/posts/alternatives-to-php-array-search/</link>
      <pubDate>Sun, 08 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/alternatives-to-php-array-search/</guid>
      <description>개요 떡밥 투척 boolean 검사코드 나는 success==false 파벌  https://twitter.com/if1live/status/662925445990498304
집에서 뒹굴다가 뜬금없는 떡밥이 생각나서 트위터에 투표를 던졌다. 투표를 던지고 보니 생각보다 많은 사람들이 if(!success) 를 선호하더라. 나같은 success==false 파벌이 얼마 없는걸 보고 왜 내가 success==false 파벌이 되었나 생각을 했다. 그리고 원인을 찾게 되었는데&amp;hellip;.
PHP array_search() PHP로 간단한 함수를 짜보자. 한자리수 정수를 넣으면 소수인지 아닌지 확인하는 함수이다. 제대로 구현하기 매우 귀찮았기 때문에 소수 목록을 하드코딩했다. 이 함수를 구현하기 위해서 PHP에서 제공하는 array_search() 를 이용했다.</description>
    </item>
    
    <item>
      <title>bit mask로 사람 낚기. (flags &amp; MASK == MASK)</title>
      <link>https://libsora.so/posts/deceiving-code-bitmask/</link>
      <pubDate>Sun, 01 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/deceiving-code-bitmask/</guid>
      <description>낚시 코드 C/C++ 에서는 한번에 여러개의 플래그를 넘길떄 비트 연산자를 사용하기도 한다. 다음은 간단한 예제 코드이다. 사용 가능한 플래그로는 fullscreen, stencil, double buffer가 있다. 이중에서 fullscreen, double buffer를 비트 OR 연산자를 이용해서 합친 다음에 함수로 넘겼다. 그리고 함수에서는 어떤 플래그가 켜져있는지 확인해서 적절한 출력을 한다.
#include &amp;lt;stdio.h&amp;gt; typedef enum { WIN_MODE_FULLSCREEN = 1 &amp;lt;&amp;lt; 0, WIN_MODE_STENCIL = 1 &amp;lt;&amp;lt; 1, WIN_MODE_DOUBLE_BUFFER = 1 &amp;lt;&amp;lt; 2 } win_mode_t; int create_window(win_mode_t mode) { if(mode &amp;amp; WIN_MODE_FULLSCREEN == WIN_MODE_FULLSCREEN) { printf(&amp;quot;fullscreen\n&amp;quot;); } if(mode &amp;amp; WIN_MODE_STENCIL == WIN_MODE_STENCIL) { printf(&amp;quot;stencil\n&amp;quot;); } if(mode &amp;amp; WIN_MODE_DOUBLE_BUFFER == WIN_MODE_DOUBLE_BUFFER) { printf(&amp;quot;double buffer\n&amp;quot;); } return 0; } int main() { create_window(WIN_MODE_FULLSCREEN | WIN_MODE_DOUBLE_BUFFER); return 0; }  $ make buggy &amp;gt; /dev/null buggy.</description>
    </item>
    
    <item>
      <title>HTML textarea의 개행문자는 무엇일까?</title>
      <link>https://libsora.so/posts/what-is-textarea-newline/</link>
      <pubDate>Sun, 25 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/what-is-textarea-newline/</guid>
      <description>개요 내가 요즘에 만드는 것은 HTTP기반의 모바일 게임이다. 서버와 클라는 HTTP로 통신을 하고 클라는 서버의 요청을 예쁘게 그려주는 역할을 수행한다. 간단히 말하면 서버는 그냥 웹서버고 클라는 특별한 브라우저라고 할 수 있다.
런칭 직전에 게임에서 이상한 버그를 발견했다. 관리도구에서 열어보면 {first-line}{newline}{second-line} 으로 보이는데 실제 게임에 보면 {first-line}{newline}{newline}{second-line} 으로 보이는 버그였다. 의도하지 않게 개행이 하나 더 들어갔다.
찾기는 어려웠지만 원인은 생각보다 간단했다. 의도하지 않은 CR 이 DB에 저장되어 있고 클라가 CR 을 제대로 처리를 하지 않아서 두줄짜리 개행으로 보인거였다.</description>
    </item>
    
    <item>
      <title>스택 지역 변수의 주소값을 이용한 버그</title>
      <link>https://libsora.so/posts/stack-allocation-voodoo-magic/</link>
      <pubDate>Wed, 07 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/stack-allocation-voodoo-magic/</guid>
      <description>얼마전에 gcc와 clang이 정렬되지 않은 구조체(예를 들어 구조체의 크기가 7바이트) 를 어떤식으로 메모리에 배치하는지 테스트하다가 재밌는 현상을 발견해서 간단하게 정리했다.
스택에 지역변수가 어떤 순서로 쌓일까? C/C++의 경우 지역변수는 스택에 배치된다. 함수에서 두개의 지역변수를 만들자. (각각의 지역변수를 x, y라고 부르자) 두개의 지역변수는 메모리의 어떤 주소에 배치될 것이다. 이때 x, y 중에서 어떤 변수의 메모리 주소값이 높을까? 이를 확인해보려고 아래의 코드를 작성해서 실행해보았다.
#include &amp;lt;stdio.h&amp;gt; int main() { int x; int y; int diff = (unsigned long)&amp;amp;x - (unsigned long)&amp;amp;y; printf(&amp;quot;addr x : %lx\n&amp;quot;, (unsigned long)&amp;amp;x); printf(&amp;quot;addr y : %lx\n&amp;quot;, (unsigned long)&amp;amp;y); printf(&amp;quot;addr diff: %d\n&amp;quot;, diff); return 0; }  gcc simple.</description>
    </item>
    
    <item>
      <title>코드에 반각/전각문자 넣어서 낚시하기</title>
      <link>https://libsora.so/posts/deceiving-code-fullwidth-halfwidth/</link>
      <pubDate>Mon, 27 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/deceiving-code-fullwidth-halfwidth/</guid>
      <description>개요  프로그래머 머리 터지게 하는 방법 작업중인 코드를 몰래 열어 세미콜론(;) 하나를 그리스어 물음표(;)로 바꾼다 tweet
 세미콜론(;) 하나를 그리스어 물음표(;)로 바꾼다면 트윗대로 프로그래머를 엿먹일수 있다. 하지만 그리스어 물음표를 볼 일이 얼마나 있을까? 우리는 그리스어를 쓰지 않고 그리스 근처의 나라도 아닌데? 악의를 가지고 코드를 수정하지 않는 이상 위의 코드를 볼 일은 없다. 그렇다면 이건 어떨까?
 프로그래머 머리 터지게 하는 방법 작업중인 코드의 정규식을 몰래 열어 반각 공백문자 2개( )를 전각 공백문자 1개(　)로 바꾼다 tweet</description>
    </item>
    
    <item>
      <title>사람 낚는 strcmp()의 리턴타입 재설계하기</title>
      <link>https://libsora.so/posts/my-strcmp/</link>
      <pubDate>Tue, 21 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/my-strcmp/</guid>
      <description>strcmp()로 낚시하기 &amp;ldquo;좋은 함수 함수의 예를 쓰시오.&amp;rdquo; 이것은 어려운 질문이다. 사람마다 좋다고 생각하는 기준이 다르기 때문에 좋은 함수의 기준이 달라진다. 반대로 후진 함수를 쓰라는건 어떨까? 모든 사람이 공감할수 있는 후진 함수가 존재하지 않을까? 이런 생각을 하다 strcmp()로 간단한 코드를 작성했다.
#include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int main() { if(strcmp(&amp;quot;foo&amp;quot;, &amp;quot;foo&amp;quot;) == true) { printf(&amp;quot;same\n&amp;quot;); } else { printf(&amp;quot;different\n&amp;quot;); } return 0; }  출력 결과가 무엇일까? different이다. strcmp 함수는 두 문자열이 같을때 0을 반환한다.</description>
    </item>
    
    <item>
      <title>&#34;foo&#34; &#34;bar&#34; == &#34;foobar&#34;</title>
      <link>https://libsora.so/posts/string-literal-concatenation-technique/</link>
      <pubDate>Mon, 20 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/string-literal-concatenation-technique/</guid>
      <description>개요 print(&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; == &amp;quot;foobar&amp;quot;)  $ python intro.py True  C에는 문자열과 문자열 사이에 공백문자가 존재할때 두 문자열을 붙여서 하나의 문자열로 취급하는 문법이 있다. 이것을 String literal concatenation라고 부른다. 해당 문법은 C뿐만 아니라 C++, Python 등 몇가지 언어도 존재한다. 이 글에서 직접 사용해본 쓸모있는 String literal concatenation 기법을 정리해보았다.
빛 URL Generate 당신이 String literal concatenation을 모른다고 가정하자. 이 상태에서 아래의 조건을 만족하는 코드를 작성해보자.
 디버그/릴리즈에 환경에 따라 Hostname이 다르다 여러 가지 URL이 존재한다 URL은 바뀔 필요 없다 각각의 URL 길이를 알아야 한다  #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; TMP를 이용해서 2015년의 13일의 금요일 계산하기</title>
      <link>https://libsora.so/posts/friday-the-13th-tmp/</link>
      <pubDate>Mon, 13 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/friday-the-13th-tmp/</guid>
      <description>개요 2015년 3월 15일에 코딩 전력 60분!에서 13일의 금요일을 구하는 문제를 던졌다. 다음 트윗에서 Short coding을 목표로 제시했지만 나는 그걸 못봤다. 그래서 아무 생각없이 몇년만에 C++ Template Metaprogramming로 흑마법을 써보기로 했다. 실력이 없어서 1시간 안에 작성하는 것은 실패했지만 어떻게든 완성시켜서 코드를 Gist에 올려두었다. 코드 작성한지 1달정도 지나니 어떻게 짯는지 기억이 안나서 글로 정리하면서 코드를 개선해보기로 했다.
제약사항 오랜만에 C++ Template Metaprogramming로 흑마법을 쓰는만큼 제대로 써보기로 했다. 추가로 1달만에 코드를 수정하는거니 몇가지 제약을 걸었다.</description>
    </item>
    
    <item>
      <title>나는 unsigned가 싫어요</title>
      <link>https://libsora.so/posts/i-hate-unsigned/</link>
      <pubDate>Thu, 04 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/i-hate-unsigned/</guid>
      <description>개요 Youtube, 강남스타일 MV 조회수가 32비트 정수 범위를 넘어섰다고 밝혀 를 보니까 댓글에서 &amp;ldquo;왜 unsigned안쓰고 signed썻냐?&amp;rdquo; 같은 소리를 하길래 내가 unsigned를 싫어하는 이유를 정리했다.
그림 한장으로 설명하는 내가 unsigned를 싫어하는 이유 https://twitter.com/yun1007com/status/540019367686070272
왜 나는 unsigned가 싫은가? 계산하기 쉽게 8 bit를 기준으로 했다. 8 bit의 세계에서 signed는 -128~127, unsigned는 0~255까지 표현 가능하다.
Unsigned - Unsigned 1 - 2 를 계산한다고 하자. 0x01과 0x02를 빼면 0xFF가 나온다. 이것은 부호가 있는 세상에서는 -1이지만 부호가 없는 세상에서는 255이다.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;에서 Python의 with statment 구현하기</title>
      <link>https://libsora.so/posts/with-statement-cpp/</link>
      <pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/with-statement-cpp/</guid>
      <description>파이썬에는 객체의 생성과 소멸의 범위를 확실하게 정하는 목적으로 with 문법이 존재한다. 파이썬은 C와 달리 블럭 스코프를 이용해서 객체의 생성주기를 통제할수 없기 때문에 with가 존재한다.
with open(&amp;quot;x.txt&amp;quot;) as f: data = f.read() ...  C에서는 블럭 스코프가 존재하기 때문에 with statement가 필요없지만 그래도 한번 만들어본 이유는 리눅스 커널의 for_each_process 매크로를 보고 for문을 매크로로 이용해서 확장하는 것이 가능하겠다는 생각을 했기 때문이다.
#define for_each_process(p) \ for (p = &amp;amp;init_task ; (p = next_task(p)) !</description>
    </item>
    
    <item>
      <title>EZ430-Chronos 개발 후기</title>
      <link>https://libsora.so/posts/ez430-chronos-development-review/</link>
      <pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/ez430-chronos-development-review/</guid>
      <description>최근에 ez430-chronos 를 가지고 놀면서 나만의 펌웨어 를 만들었다. ez430-chronos 갖고 노는걸 끝내기 전에 그동안 삽질했던 경험+교훈을 정리해봤다. (별거 없지만)
uint8_t, uint16_t, uint32_t, int8_t, int16_t, int32_t 일반적인 데스크탑환경, 또는 모바일환경(iOS, Android)에서 프로그래밍할때는 타입을 그렇게 신경쓰지 않았다. 32비트 환경이고 사양 높고 메모리가 넉넉하니 char를 쓰건 short를 쓰건 int를 쓰건 문제가 안생기니까 신경쓸 필요도 없었다. (char=1byte, short=2byte, int=4byte가 아니라는건 알고있지만 일단 무시한다)
하지만 임베디드에서는 이야기가 다르더라. 남들이 짜놓은 코드를 보니 uint8_t, uint16_t, uint32_t를 골라서 사용하더라.</description>
    </item>
    
    <item>
      <title>파이썬 엑셀 쓰기 라이브러리 비교</title>
      <link>https://libsora.so/posts/python-excel-library/</link>
      <pubDate>Sun, 23 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/python-excel-library/</guid>
      <description>subtitle: 무엇을 골라야 후회하지 않는가?
리눅스에서 굴러가는 파이썬 기반의 통계 도구를 만든적이 있다. 리눅스에서도 굴러가는 엑셀 라이브러리를 몇개 찾아봤고 직접 써본 다음에 정리했다. 찾아본 엑셀 라이브러리는 다음과 같다.
 xlwt OpenPyXL XlsxWriter PyExcelerate  이중에서 내가 직접 사용해본것은 xlwt, OpenPyXL, XlsxWriter이다. (사용해본 순서로 적었다.)
supoort xlsx xls와 xlsx의 가장 큰 차이는 행, 열의 최대 갯수가 65535라는거다. 몇만건의 데이터를 다룰 가능성이 있다면 xlsx 지원하는 라이브러리를 사용해야 나중에 또 짜는 삽질은 안한다.</description>
    </item>
    
    <item>
      <title>Wireless Latency Benchmark</title>
      <link>https://libsora.so/posts/wireless-latency-benchmark/</link>
      <pubDate>Thu, 12 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/wireless-latency-benchmark/</guid>
      <description>요즘에 스마트폰을 게임 컨트롤러로 쓰는걸 만들고있다. 처음에는 소켓으로 구현해봤는데 latency가 못쓸물건이더라. PS3 컨트롤러는 블투투스를 쓴다길래 블투를 쓰면 latency가 얼마나 개선되는지 한번 테스트해봤다.
자세한건 repo 를 참고.</description>
    </item>
    
    <item>
      <title>LibOVR에서 찾은 적절한 assert macro</title>
      <link>https://libsora.so/posts/libovr-assert-macro/</link>
      <pubDate>Mon, 14 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/libovr-assert-macro/</guid>
      <description>개발하려면 어쨋든 assert가 있긴 해야겠더라. 근데 기본 assert를 쓰면 callstack 추적하기가 귀찮더라. 그래서 맨날 간단한 매크로(int 3) 만들어서 사용했었는데 나중에 알고보니까 해당 매크로는 64비트 환경에서 작동하지 않는다. 남들은 어떻게 하나 찾아보다가 때마침 Oculus SDK를 보게 되었는데 매우 적절하게 있어서 그냥 갖다쓴다. 원본 소스는 OVR_Types.h 이다.
// Microsoft Win32 specific debugging support #if defined(OVR_OS_WIN32) # ifdef OVR_CPU_X86 # if defined(__cplusplus_cli) # define OVR_DEBUG_BREAK do { __debugbreak(); } while(0) # elif defined(OVR_CC_GNU) # define OVR_DEBUG_BREAK do { OVR_ASM(&amp;quot;int $3\n\t&amp;quot;); } while(0) # else # define OVR_DEBUG_BREAK do { OVR_ASM int 3 } while (0) # endif # else # define OVR_DEBUG_BREAK do { __debugbreak(); } while(0) # endif // Unix specific debugging support #elif defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64) # define OVR_DEBUG_BREAK do { OVR_ASM(&amp;quot;int $3\n\t&amp;quot;); } while(0) #else # define OVR_DEBUG_BREAK do { *((int *) 0) = 1; } while(0) #endif // This will cause compiler breakpoint #define OVR_ASSERT(p) do { if (!</description>
    </item>
    
    <item>
      <title>Controller for Raspberry Pi &#43; MPD</title>
      <link>https://libsora.so/posts/rpi-mpd-controller/</link>
      <pubDate>Sat, 20 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/rpi-mpd-controller/</guid>
      <description>Controller for Raspberry Pi + MPD</description>
    </item>
    
    <item>
      <title>완벽한 싱글턴을 찾아서 - 테스트</title>
      <link>https://libsora.so/posts/singleton-test/</link>
      <pubDate>Tue, 18 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/singleton-test/</guid>
      <description>이전에 사람들이 많이 사용하는 방식의 싱글턴을 까는 글을 쓰고 그것을 해결책을 정리했었다.(사실은 복붙에 더 가깝지만&amp;hellip;) 최근에 조금 더 생각해보니 그거보다 더 좋은 방법(특히 테스트측면에서)이 생각나서 똑같은 주제를 재탕하기로 했다.
테스트에서 싱글턴의 뭐가 문제인가? 전역변수 기반의 싱글턴이 사고치는 경우를 준비하자.
 FileSystem이라는 싱글턴 클래스가 존재한다. 싱글턴으로 사용하는 전역변수의 이름은 gFileSystem이다. 그리고 gFileSystem을 기반으로 구현된 PackageManager라는 클래스가 있다. PackageManager에는 foo(), bar()라는 함수가 존재한다.
 위의 상황에 대응하는 유닛테스트를 다음과 같이 작성했다.
class PackageManagerTest : public ::testing::Test { protected: virtual void SetUp() { gFileSystem.</description>
    </item>
    
    <item>
      <title>나는 싱글턴이 싫어요</title>
      <link>https://libsora.so/posts/i-hate-singleton/</link>
      <pubDate>Sun, 19 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/i-hate-singleton/</guid>
      <description>옛날에는 싱글턴을 자주 썼는데 요즘에는 안쓴다. 내가 싱글턴을 안쓰게 된 몇가지 이유가 있는데 다음과 같다
소멸 시점이 있긴한가? static을 이용해서 구현한 싱글턴 설계에서 존재하는 문제점이다.
class Singleton { private: Singleton() {} Singleton(const Singleton&amp;amp; other); public: static Singleton&amp;amp; getInstance() { static Singleton ctx; return ctx; } };  Singleton::getInstance()함수를 호출하면 싱글턴을 적절히 사용할수있다. 하지만 소멸은&amp;hellip;? 싱글턴의 소멸은 OS님께서 알아서 해주시는거 외에는 기대할 방법이 없다. 싱글턴 A/B/C가 있는데 의존성 문제로 각각이 일정한 순서로 소멸되어야한다면?</description>
    </item>
    
    <item>
      <title>Box2D Common Module</title>
      <link>https://libsora.so/posts/box2d-common/</link>
      <pubDate>Tue, 12 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/box2d-common/</guid>
      <description>Math InvSqrt /// This is a approximate yet fast inverse square-root. inline float32 b2InvSqrt(float32 x) { union { float32 x; int32 i; } convert; convert.x = x; float32 xhalf = 0.5f * x; convert.i = 0x5f3759df - (convert.i &amp;gt;&amp;gt; 1); x = convert.x; x = x * (1.5f - xhalf * x * x); return x; }  quake3 이후로 계속 많이 쓰인다는 Fast Inverse square root 함수. 처다보기만해도 정신이 우주로 가능 magic number가 내장되어잇다.</description>
    </item>
    
    <item>
      <title>C#에서 C&#43;&#43; DLL 사용하기</title>
      <link>https://libsora.so/posts/csharp-cpp-dll/</link>
      <pubDate>Tue, 12 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/csharp-cpp-dll/</guid>
      <description>개요 C#에서 C++ dll을 사용하기 위해서는 pinvoke(platform invoke)를 사용하면 된다. 아래의 내용은 사용법에 대한 간단한 정리이다. 내용 생략하고 Sample 를 받아도 된다.
C++ h // Ŭnicode please #pragma once #include &amp;lt;cstdio&amp;gt; namespace ns {; typedef struct tTest { char strTest[128]; //문자열 128 int intTest; //숫자형 char byteTest[64]; //바이트형 배열 unsigned int uintTest[4]; //유니트형 배열 } typeTest; } extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest1(void); //기본형 extern &amp;quot;C&amp;quot; __declspec(dllexport) int intOnTest2(int intTemp); //입출력 숫자형 extern &amp;quot;C&amp;quot; __declspec(dllexport) int* strOnTest3(); //입출력 문자열형 extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest4(ns::typeTest *testTemp); //입력 구조체(포인터 출력가능) extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest5(int *intTemp); //입출력 배열(포인터 출력가능)   문자열을 반환하는 경우 char포인터를 리턴하는 대신 int*를 리턴하고 C#쪽에서 적절히 캐스팅해서 받아야한다 C#쪽에서 구조체를 구성하는것은 메모리 구조만 맞추면 되니까 네임스페이스건 뭐건 잇건 없건 큰 문제가 없다 dll 인터페이스로 만들기 위해서 extern &amp;quot;C&amp;quot; __declspec(dllexport)를 함수에 넣어준다  cpp // Ŭnicode please #include &amp;quot;sample.</description>
    </item>
    
    <item>
      <title>Python 2.x 한글 인코딩 관련 정리</title>
      <link>https://libsora.so/posts/python-hangul/</link>
      <pubDate>Sun, 03 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/python-hangul/</guid>
      <description>개요 파이썬은 양놈이 만든 언어라서 한글을 쓸때 골치아프다 (아니, 한글만 골치아픈게 지옥의 언어 CJK(chiness, japanese, korean)를 포함한 멀티바이트 언어는 전부 그렇겠지). 영어만 사용하면 별로 신경쓸게 없지만 한글은 euc-kr, utf-8이 공존하지 않는가?
그냥 골치아픈것도 아니고 unicode와 조합되서도 골치아프다. unicode관련 부분의 경우, 최초부터 지원한게 아니라 파이썬 2.4(엿던가?)부터 지원이 추가되어서 문자열을 의미하는 타입이 str과 unicode가 존재해서 더 골치아프다. 이런 문제는 파이썬 3.X로 가면 거의 없어지지만(그 동네는 unicode로 통일됏다고하더라.) 외부 라이브러리라든가 기타 사정상 파이썬 2.</description>
    </item>
    
    <item>
      <title>auto_ptr을 썻는데 소멸자가 불리지 않는다?</title>
      <link>https://libsora.so/posts/auto-ptr/</link>
      <pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/auto-ptr/</guid>
      <description>auto_ptr은 아주 간단한 스마트 포인터의 일정으로 동적할당된 객체를 자동으로 delete하는데 쓰인다. 하지만 잘못된 코딩을 하면 소멸자가 호출되지 않는다. 소멸자를 호출시키지 않는 auto_ptr의 예제이다
문제의 소스 main.cpp // Ŭnicode please #include &amp;lt;memory&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;quot;example.h&amp;quot; using namespace std; class SampleObj { public: ~SampleObj() { printf(&amp;quot;dtor\n&amp;quot;); } }; int main() { Example *ex = new Example(new SampleObj()); delete(ex); getchar(); return 0; }  example.h // Ŭnicode please #pragma once #include &amp;lt;memory&amp;gt; class SampleObj; class Example { public: Example(SampleObj *obj); ~Example(); std::auto_ptr&amp;lt;SampleObj&amp;gt; ptr_obj; };  example.</description>
    </item>
    
    <item>
      <title>Box2d Block Allocator</title>
      <link>https://libsora.so/posts/box2d-block-allocator/</link>
      <pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/box2d-block-allocator/</guid>
      <description>작은크기의 객체를 많이 할당할때 사용되는 할당자이다. 기본설정값의 경우, 대략 640byte보다 작은 메모리를 많이 요청할때 사용한다
기본 구조 Chunk, Block의 2가지 개념으로 나누어서 메모리를 관리한다. Chunk는 16kb(기본값)을 하나의 크기로 가짆다. Chunk는 하나의 거대한 메모리 덩어리이고 이를 적절히 block이라든 작은 단위로 잘라서 사용한다.
메모리를 몇 byte로 요청하든간에 정해진 크기의 메모리로 할당한다. 같은 크기의 메모리블럭을 모아서 관리하기 위한 편법으로 이를 채택한듯하다. 허용 가능한 메모리 할당 크기는 s_blockSizes에 정의되어잇다. 16, 13, 64, &amp;hellip;.640 등이 가능하다.</description>
    </item>
    
    <item>
      <title>Box2d Stack Allocator</title>
      <link>https://libsora.so/posts/box2d-stack-allocator/</link>
      <pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/box2d-stack-allocator/</guid>
      <description>구조 고정크기로 b2_stackSize(기본값 100kb)의 메모리를 가지고 이것을 맨앞부터 쪼개서(그래서 스택기반) 사용하는 할당자이다. 구조가 단순한만큼 빠르다. 초기화에서 한번에 여러개를 할당하고 몰아서 해제하는 객체 로딩같은곳에서 사용 가능할듯하다.
할당한 순서와 정확히 반대로 해제해야 정상 작동한다. (그래야 스택답지)
const int32 b2_stackSize = 100 * 1024;	// 100k const int32 b2_maxStackEntries = 32; struct b2StackEntry { char* data; int32 size; bool usedMalloc; };  Stack Allocator안에는 100kb의 고정크기배열이 내장되어잇다. 사용자가 메모리를 요청하면 이를 쪼개서 반환한다. 만약 메모리가 딸리면 시스템 Malloc로 추가 메모리를 할당한다.</description>
    </item>
    
    <item>
      <title>C#의 프로퍼티 C&#43;&#43;에서 쓰기</title>
      <link>https://libsora.so/posts/charp-like-property/</link>
      <pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/charp-like-property/</guid>
      <description>본문을 읽기전에 아래의 2개의 페이지를 읽어보면 이해에 도움이 될것이다. 사실상 내가 만든 코드는 위의 2개를 내 방식대로 묶은것뿐이다
 [Property(programming)][1] [C++에서 속성 구현하기][2] [1]: http://en.wikipedia.org/wiki/Property_(programming)#C.2B.2B [2]: http://www.gpgstudy.com/forum/viewtopic.php?t=3504  Step 1. C# 느낌의 프로퍼티를 C++에서 왜 쓰고 싶은가? 단계별로 코드를 안드로보내기 위해서 처음에는 간단한것부터 시작하자.
class Obj { public: int a; }; Obj obj; obj.a = 1; printf(&amp;quot;%d\n&amp;quot;, obj.a);  위의 코드처럼 클래스에 있는 멤버변수가 public이라면 그냥 .찍는것으로 변수를 얻을수있다. 하지만 개인적으로 public변수의 떡칠을 싫어한다.</description>
    </item>
    
    <item>
      <title>cocos2d-x 메모리 관리에 대한 간단한 정리</title>
      <link>https://libsora.so/posts/cocos2dx-memory-management/</link>
      <pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/cocos2dx-memory-management/</guid>
      <description>cocos2d-x는 cocos2d를 거의 그대로 포팅한 2d게임 엔진이다. 원작이 objc 기반인 cocos2d를 C++로 옮겼으니 완전히 똑같지는 않다. 특히 메모리 모델의 경우는 언어상의 차이로 다를수밖에 없다.
objc의 메모리 관리는 기본적으로 레퍼런스 카운팅 방식이다. 모든 objc의 클래스는 NSObject를 상속받는다. retain, release를 적절히 써서 레러런서 카운팅 쌍을 맞춰주면 적절히 메모리가 관리된다. autorelease를 사용하면 NSAutoreleasePool에 생성된 객체가 등록된다. 이후 NSAutoreleasePool이 해제되면 풀에 등록된 모든 객체에 대해서 release를 수행한다.
하지만 C++에는 기본적으로는 저런기능이 존재하지 않는다. new로 객체를 생성하고 delete로 객체를 해제한다.</description>
    </item>
    
    <item>
      <title>memset로 클래스 초기화 쉽게 하기</title>
      <link>https://libsora.so/posts/class-init-with-memset/</link>
      <pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/class-init-with-memset/</guid>
      <description>일반적으로 C++에서는 멤버변수 초기화를 다음과 같은 문법으로 한다.
class SomeClass { public: SomeClass() : a(0), b(0) {} private: int a; float b; };  만약 클래스안에 멤버변수가 많다면 위와 같은 문법으로 코딩하는게 심히 귀찮다.(예를 들면 파티클 클래스 같은 경우)
class ParticleParamter { public: ParticleParamter() : pos_x(0), pos_y(0), pos_z(0), vel_x(0), vel_y(0), vel_z(0),....... float pos_x, pos_y, pos_z; float vel_x, vel_y, vel_z; float begin_r, begin_g, begin_b, begin_a; .... };  어차피 내부의 멤버변수가 0으로 초기화되어야한다면 좀더 쉽게 할수 있는 방법이 있지 않을까?</description>
    </item>
    
    <item>
      <title>집합 기반 태그 시스템 설계</title>
      <link>https://libsora.so/posts/set-based-tag/</link>
      <pubDate>Tue, 18 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/set-based-tag/</guid>
      <description>집합 기반 태그 시스템 설계</description>
    </item>
    
    <item>
      <title>윈도/ios/안드로이드를 커버할수 있는 PCH 구조 잡기</title>
      <link>https://libsora.so/posts/cross-platform-stdafx/</link>
      <pubDate>Sat, 08 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/cross-platform-stdafx/</guid>
      <description>윈도/ios/안드로이드를 커버할수 있는 PCH 구조 잡기</description>
    </item>
    
    <item>
      <title>cocos2d-x 1.x-&gt;2.0으로 변하면서 바뀐 부분 :: CCPoint</title>
      <link>https://libsora.so/posts/ccpoint-lua/</link>
      <pubDate>Tue, 04 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/ccpoint-lua/</guid>
      <description>cocos2d-x 1.x-&amp;gt;2.0으로 변하면서 바뀐 부분 :: CCPoint</description>
    </item>
    
    <item>
      <title>플랫폼 매크로 추가 선언 없이 윈도/iOS/안드로이드 구분하는 매크로</title>
      <link>https://libsora.so/posts/platform-macro/</link>
      <pubDate>Fri, 30 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/platform-macro/</guid>
      <description>플랫폼 매크로 추가 선언 없이 윈도/iOS/안드로이드 구분하는 매크로</description>
    </item>
    
    <item>
      <title>C&#43;&#43; namespace 들여쓰기 방지하는 편법</title>
      <link>https://libsora.so/posts/namespace-indent/</link>
      <pubDate>Wed, 28 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/namespace-indent/</guid>
      <description>C++ namespace 들여쓰기 방지하는 편법</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 다중상속(interface) 관련 삽질 자료</title>
      <link>https://libsora.so/posts/cpp-casting/</link>
      <pubDate>Tue, 27 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/cpp-casting/</guid>
      <description>C++ 다중상속(interface) 관련 삽질 자료</description>
    </item>
    
    <item>
      <title>생성자,소멸자 강제호출</title>
      <link>https://libsora.so/posts/call-ctor-dtor/</link>
      <pubDate>Mon, 26 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://libsora.so/posts/call-ctor-dtor/</guid>
      <description>개요 성능, 혹은 디버깅을 위해서 커스텀 malloc/free를 쓰는 일이 잇다. 문제는 malloc/free로 사용하면 소멸자/생성자가 호출되지 않기 떄문에 C++에 그냥 통합할수는 없다. 편법으로 delete/new를 오버라이딩해서 쓸수도 잇지만 이경우 클래스에 하나에 대해서 2가지 이상의 malloc함수를 사용할수 없다.
구현 예제 구현체 template&amp;lt;typename T&amp;gt; void CallConstructor(T *ptr) { new(ptr) T; } template&amp;lt;typename T&amp;gt; void CallDestructor(T *ptr) { ptr-&amp;gt;~T(); }  사용법 struct CtorDtorSample { CtorDtorSample() { value = 1; } ~CtorDtorSample() { value = 0;} static int value; }; int CtorDtorSample::value = -1; TEST(CallConstructor_CallDestructor, test) { using namespace sora; EXPECT_EQ(-1, CtorDtorSample::value); CtorDtorSample *ptr = (CtorDtorSample*)malloc(sizeof(CtorDtorSample)); CallConstructor(ptr); EXPECT_EQ(1, CtorDtorSample::value); CallDestructor(ptr); free(ptr); EXPECT_EQ(0, CtorDtorSample::value); }  Reference  http://kldp.</description>
    </item>
    
  </channel>
</rss>
