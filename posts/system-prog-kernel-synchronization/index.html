<!doctype html>
<html class="no-js" lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.78.1" />

  <title> Kernel Synchronization &middot; /usr/lib/libsora.so </title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="naver-site-verification" content="2ddc1a56777489f4a64a4f6a59822f8b1c1ea502"/>
  <meta name="google-site-verification" content="VsvNNnJZUV-iLEYKNju16p-HtDqZeqL15H-VVy-HwpA" />

  <meta name="gc:client-id" content="785d47c81cbc2fd42b65">
  <meta name="gc:client-secret" content="5e5d558f0b16fae154aa47fc9d94f7c09e540ec7">

  
  <meta name="author" content="if1live" />
  

  
  <meta name="description" content="Kernel Synchronization" />
  

  
  <meta name="keywords" content="linux, system programming, synchronization" />
  

  
  
<meta name="twitter:card" content="summary">
<meta name="og:url" content="https://libsora.so/posts/system-prog-kernel-synchronization/">

<meta name="twitter:site" content="@if1live">


<meta name="twitter:title" content="Kernel Synchronization">
<meta name="twitter:description" content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Kernel Synchronization Kernel Control Paths   커널 함수는 다음 요청에 따라서 실행된다
 유저 모드에서 실행되는 프로세스에서 예외 발생  int 0x80, sysenter : system call   외부 장비가 IRQ Line을 이용해서 PI">

<meta name="twitter:image:src" content="https://www.gravatar.com/avatar/fb9672e7e0d256f39369595381d1ea07">



  

  
  
  <link rel="stylesheet" href="https://libsora.so/css/style-gen.css?2">

  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />

  
  <link href="https://libsora.so/index.xml" rel="alternate" type="application/rss+xml" title="/usr/lib/libsora.so" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/themes/prism.min.css"
  integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ=="
  crossorigin="anonymous" />
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.css"
  integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ=="
  crossorigin="anonymous" />

  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css"
  integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw=="
  crossorigin="anonymous" />


  
  <script type="text/javascript">
    var host = "libsora.so";
    if ((host == window.location.host) && (window.location.protocol != "https:")) {
      window.location.protocol = "https";
    } else {
      console.log("skip https redirect");
    }
  </script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: "ca-pub-3043297488880636",
  enable_page_level_ads: true
});
</script>

</head>
<body>

<header class="header">
  <h1 class="font-monospace">
    <a href="https://libsora.so/">/usr/lib/libsora.so</a>
  </h1>
  <nav>
    <h2 hidden>Navigation</h2>
    <ul class="nav-link-list">
      <li>
        <a href="https://libsora.so/about/"  title="about">
          <i class="fa fa-info"><span hidden>about</span></i>
        </a>
      </li>
      <li>
        <a href="https://libsora.so/projects/"  title="projects">
          <i class="fa fa-code"><span hidden>projects</span></i>
        </a>
      </li>
      <li>
        <a href="https://libsora.so/archives/"  title="archives">
          <i class="fa fa-archive"><span hidden>Archives</span></i>
        </a>
      </li>
      <li>
        <a href="https://libsora.so/tags/"  title="tags">
          <i class="fa fa-tags"><span hidden>Tags</span></i>
        </a>
      </li>
      <li>
        <a href="https://libsora.so/search/"  title="search">
          <i class="fa fa-search"><span hidden>Search</span></i>
        </a>
      </li>
    </ul>
  </nav>
</header>


<div class="container">
  <article class="basic-content article-content">
    <header>
      <hgroup class="entry-title">
        <a href="/posts/system-prog-kernel-synchronization/" rel="bookmark" title="Permalink to Kernel Synchronization">
          <h1>Kernel Synchronization</h1>
          
          <h2>2014년 2학기 시스템 프로그래밍 시험 공부</h2>
          
        </a>
      </hgroup>
    </header>

    <footer class="post-info">
      <abbr class="published" title='2014-11-24T00:00:00Z'>
        2014/11/24
      </abbr>
      
      <address class="vcard author">
        By <a href="//twitter.com/if1live">@if1live</a>
      </address>
      

      <ul class="list-of-tags tags-in-article">
        
        <li>
          <a href="/tags/linux">#linux</a>
        </li>
        
        <li>
          <a href="/tags/system-programming">#system programming</a>
        </li>
        
        <li>
          <a href="/tags/synchronization">#synchronization</a>
        </li>
        
      </ul>
    </footer>

    <section class="entry-content">
      <p>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.</p>
<h1 id="kernel-synchronization">Kernel Synchronization</h1>
<h2 id="kernel-control-paths">Kernel Control Paths</h2>
<ul>
<li>
<p>커널 함수는 다음 요청에 따라서 실행된다</p>
<ul>
<li>유저 모드에서 실행되는 프로세스에서 예외 발생
<ul>
<li>int 0x80, sysenter : system call</li>
</ul>
</li>
<li>외부 장비가 IRQ Line을 이용해서 PIC로 시스널을 보낼때
<ul>
<li>해당되는 인터럽트가 활성화 되어있는 경우</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Kernel Control Paths (KCP)</p>
<ul>
<li>커널모드에서 커널요청을 처리하려고 수행되는 코드
<ul>
<li>요청이란? system call, interrupt, exception</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CPU는 kernel control paths를 상호배치(interleave)</p>
<ul>
<li><code>schedule()</code> 가 호출될때 context switch 발생</li>
<li>kernel control path 실행 도중 인터럽트가 끼어들수 있다 (nested interrupt)
<ul>
<li>이경우, 첫번째 kernel control path는 끝나지 않은 상태로 남게된다.</li>
<li>인터럽트를 처리하기 위해서 다른 kernel control path가 시작된다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>kernel control path를 상호배치하는 것은 중요</p>
<ul>
<li>멀티프로세싱 구현</li>
<li>PIC와 디바이스 컨트롤러의 처리량 개선</li>
</ul>
</li>
<li>
<p>이슈</p>
<ul>
<li>kernel control path를 상호배치하면 커널자료 구조에 동시에 접근하는 경우를 고려해야한다</li>
<li><strong>Race condition</strong>을 막기 위해서 커널 동기화가 필요</li>
</ul>
</li>
</ul>
<h2 id="race-conditions">Race Conditions</h2>
<ul>
<li>정의
<ul>
<li>2개 이상의 KCP가 동시에 실행되면 결과가 영향을 받는 경우</li>
<li><strong>Critical Region</strong> : 각각의 kernel control path에 의해 완전히 실행해야 되는 코드</li>
</ul>
</li>
<li>리눅스 커널에는 경쟁상태가 발생할수 있는 가짓수가 많다
<ul>
<li>커널 코드는 여러 CPU 위에서 돌아간다</li>
<li>2.6 커널은 선점형
<ul>
<li>스케줄러는 커널 코드를 선점할수 있고 다른 프로세스를 스케줄할 수 있다.</li>
</ul>
</li>
<li>인터럽트 : 인터럽트 처리중에 인터럽트가 발생할수 있다.</li>
<li>softirq, tasklet : softirq나 tasklet에 의해 현재 실행중인 코드가 인터럽트 받을수 있다.</li>
<li>프로세스가 KCP 실행중에 잠들면, 다른 프로세스가 스케줄링 될 수 있다.</li>
</ul>
</li>
<li>예제
<ul>
<li>시스템콜을 호출해서 커널 모드에 진입</li>
<li>kernel control path가 critical section에 진입</li>
<li>인터럽트가 발생! 인터럽트 핸들러가 실행됨</li>
<li>인터럽트 핸들러가 critical section에 진입</li>
<li>인터럽트가 끝나고 처음 kernel control path의 critical section으로 복귀</li>
<li>인터럽트 핸들러가 첫번째 KCP와 동일한 자료구조를 건드렸다면?</li>
</ul>
</li>
</ul>
<h2 id="synchronization-primitives">Synchronization Primitives</h2>
<ul>
<li>목표 : <strong>커널 자료구조를 보호</strong>
<ul>
<li>공유데이터 사이의 경쟁상태를 피하면서 kernel control path를 상호배치하는 메카니즘 제공하기</li>
</ul>
</li>
<li>리눅스 커널의 동기화 방법
<ul>
<li>Atomic Operation</li>
<li>Locking (spin lock, kernel semaphores)</li>
<li>Interrupt disabling</li>
</ul>
</li>
</ul>
<h2 id="atomic-operations">Atomic Operations</h2>
<ul>
<li>chip 수준에서 원자적 연산을 보장
<ul>
<li>read-modify-write 과정을 1개의 명령어로 처리한다. 처리도중 인터럽트 당하지 않는다</li>
</ul>
</li>
<li>Atomic operation은 유연한 커널을 구현하고 critical section을 만드는 강력한 메커니즘으로써 사용된다.</li>
<li>Atomic operation in C
<ul>
<li><code>a = a + 1</code>은 원자적 연산이라고 보장하지 못한다</li>
<li>리눅스 커널의 경우 별도의 함수를 이용</li>
</ul>
</li>
<li>interger의 원자적 연산
<ul>
<li>include/asm-i386/atomic.h</li>
<li>data structure : <code>atomic_t</code></li>
<li><code>atomic_read(v)</code></li>
<li><code>atomic_set(v, i)</code></li>
<li><code>atomic_add(i, v)</code></li>
<li><code>atomic_inv(v)</code> &hellip;</li>
</ul>
</li>
<li>Bit operations : 특정 주소의 bit을 원자적으로 바꿈</li>
</ul>
<h2 id="locking">Locking</h2>
<ul>
<li>Kernel locking
<ul>
<li>공유 커널 자료구조나 임계구역(critical section)에 접근하려면 락(lock)을 획득해야한다</li>
</ul>
</li>
<li>리눅스에서 제공하는 2종류의 락
<ul>
<li>Spin lock : busy-waiting lock
<ul>
<li>멀티프로세서 시스템에서만 가능</li>
</ul>
</li>
<li>Kenel semaphores : blocking lock
<ul>
<li>Uni-프로세서/멀티프로세스 시스템 모두에서 널리 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="programming-with-locks">Programming with Locks</h2>
<ul>
<li>Lock은 알아서 구현해야한다
<ul>
<li>프로그래머가 락없이 공유 자료구조에 접근하는 것이 가능하다.</li>
<li>락없이 공유 자료구조에 접근하면 경쟁상태가 발생하거나 공유 데이터가 깨질수 있다.</li>
</ul>
</li>
<li>무엇에 보호가 필요한가? 다음을 확인한다.
<ul>
<li>전역 데이터인가? 쓰레드 실행중에 다른 쓰레드가 접근 가능한가?</li>
<li>process context와 interrupt context 사이에 공유하는 자료인가?</li>
<li>2개의 다른 인터럽트 핸들러에서 공유하는 자료인가?</li>
<li>현재 프로세스가 블럭될수 있는가? 그렇다면 공유데이터는 어떤 상태로 남는가?</li>
<li>프로세스가 공유데이터 접근 도중 선점된다면 다른 스케줄링된 프로세스가 같은 데이터에 접근 가능한가?</li>
</ul>
</li>
</ul>
<h2 id="lock-contention-and-scalability">Lock Contention and Scalability</h2>
<ul>
<li>Lock contention
<ul>
<li>락이 현재 사용되는데 다른 프로세스가 락을 얻으려고 시도했다.</li>
<li><strong>highly contended lock</strong>은 많은 프로세스가 동시에 락을 얻으려고 한다.</li>
<li>발생원인 : 락을 자주 잡는다, 락을 오래 잡고 있다, 둘다.</li>
</ul>
</li>
<li><strong>Lock은 작업을 직렬화한다</strong>
<ul>
<li>highly contented lock은 병목지점이 되어 시스템의 성능을 제한</li>
</ul>
</li>
<li>Scalability (확장성)
<ul>
<li>시스템이 얼마나 늘어날수 있는가?</li>
<li>CPU 2개 넣어서 성능이 2개가 되는가?</li>
</ul>
</li>
<li><strong>Highly contended lock는 확장성을 제한</strong>
<ul>
<li>모든 프로세스가 queue에 늘어서서 작업을 처리하는 형태가 된다</li>
<li>낮은 수준의 병렬 작업</li>
</ul>
</li>
</ul>
<h2 id="locking-granulartiy">Locking Granulartiy</h2>
<ul>
<li>Locking Granularity
<ul>
<li>락이 보호하는 데이터의 양을 표현</li>
</ul>
</li>
<li>Coarse-grained lock : 많은 양의 데이터를 보호
<ul>
<li>개발 쉽다</li>
<li>작업 직렬화 =&gt; 낮은 성능</li>
</ul>
</li>
<li>Find-grained lock : 적은 양의 데이터를 보호</li>
<li>개발은 coarse-grained로 시작해서 점점 fine-grained로 발전시켜 나간다</li>
<li>Example
<ul>
<li>Coarse-grained lock
<ul>
<li>시스템에 존재하는 runqueue 전체를 락 1개로 관리</li>
</ul>
</li>
<li>Medium-grained lock
<ul>
<li>CPU에 있는 runqueue별로 락 1개</li>
</ul>
</li>
<li>Find-grained lock
<ul>
<li>runqueue의 priority-list별로 락을 가진다</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="spin-locks">Spin Locks</h2>
<ul>
<li>SMP (multiprocessor) 시스템에서 사용되는 락
<ul>
<li>공유 변수를 이용</li>
<li>변수를 설정 == 락 획득</li>
<li>spin == 변수가 unset될때까지 busy-wait loop
<ul>
<li>context switch 하는 부하가 없다.</li>
</ul>
</li>
<li>spin lock을 너무 오래 잡고있으면 다른 CPU가 busy-wait 하느라 시간 낭비한다</li>
<li><code>spinlock_t</code> : include/asm-i386/spinlock.h</li>
</ul>
</li>
<li>Uni-프로세스 시스템의 경우
<ul>
<li><strong>spin lock가 필요없다</strong></li>
<li>어차피 동시에 돌아가는 프로세스가 없다</li>
<li>대기하는 프로세스는 계속 돌아가고 다른 프로세스가 락을 놓을 가능성은 없다.</li>
</ul>
</li>
</ul>
<h2 id="spin-locks-and-interrupt-handlers">Spin Locks and Interrupt Handlers</h2>
<ul>
<li>Spin lock은 SMP 환경의 인터럽트 핸들러에서 사용할수 있다.
<ul>
<li>spin lock은 block가 아니니까</li>
</ul>
</li>
<li>인터럽트 핸들러에서 락을 사용하면&hellip;
<ul>
<li><strong>락을 얻기 전에 local interrupt 비활성화</strong>
<ul>
<li>인터럽트 발생하면 nested된다. 이상태에서 락이 꼬일수 있다.</li>
</ul>
</li>
<li>local interrupt만 비활성한다. 다른 CPU의 인터럽트는 비활성화할 필요 없다.
<ul>
<li>spin lock은 local CPU에서만 돌아가니까.</li>
</ul>
</li>
</ul>
</li>
<li>Local interrupt 를 끄지 않을 때 Deadlock 발생하는 예제
<ul>
<li>인터럽트 핸들러에서 lock을 획득</li>
<li>인터럽트가 다시 들어옴, nested 발생</li>
<li>nested 인터럽트 핸들어에서 lock을 획득하려고 함</li>
<li>근데 lock은 이미 획득되었잖아? 그리고 nested 끝나기 전까지는 풀 수가 없잖아?</li>
<li>DEADLOCK</li>
</ul>
</li>
</ul>
<h2 id="readwrite-spin-locks">Read/Write Spin Locks</h2>
<ul>
<li>1 Writer, N Reader</li>
<li><code>rwlock_t</code></li>
</ul>
<h2 id="kernel-semaphores">Kernel Semaphores</h2>
<ul>
<li>Kernel semaphores == Sleeping locks
<ul>
<li>프로레스가 세마포어를 잡으려고 했지만 세마포어가 이미 잡혀있는 경우 세마포어의 대기큐에 프로세스를 넣는다.
<ul>
<li>스핀락과의 차이. 스핀락이었으면 spin 시작함</li>
</ul>
</li>
<li>다른 프로세스가 스케줄 된다</li>
<li>세마포어를 잡고있던 프로세스가 세마포어를 놓으면 세마포어의 대기큐에서 작업을 하나 꺼내서 깨운다
<ul>
<li>깨어난 프로세스가 세마포어를 잡고 작업 시작</li>
</ul>
</li>
</ul>
</li>
<li>커널 세마포어는 잠재적으로 block
<ul>
<li><strong>커널 세마포어는 sleep가 필요 =&gt; interrupt, softirq, tasklet에서 사용 불가</strong></li>
</ul>
</li>
</ul>
<h3 id="using-kernel-semaphores">Using Kernel Semaphores</h3>
<ul>
<li>count
<ul>
<li>count == 1 : MUTEX</li>
<li>count &gt; 1 : Counting Semaphore</li>
</ul>
</li>
<li>Acquire (<code>down()</code>)
<ul>
<li>atomic(sem-&gt;count&ndash;)</li>
<li>count &lt; 0 이면 current를 대기큐로</li>
</ul>
</li>
<li>Release (<code>up()</code>)
<ul>
<li>atomic(sem-&gt;count++)</li>
<li>count &lt;= 0이면 대기큐에서 1개 깨우기</li>
</ul>
</li>
</ul>
<h2 id="avoiding-deadlocks-on-semaphores">Avoiding Deadlocks on Semaphores</h2>
<ul>
<li>Deadlock
<ul>
<li>프로그램이 2개 이상의 세마포어를 사용할때</li>
<li>2개의 다른 경로가 서로 세마포어가 풀리는 것을 기다리는 경우</li>
</ul>
</li>
<li>데드락 피하는 방법
<ul>
<li><strong>리소스 정렬</strong> : 정해진 순서로 세마포어 요청</li>
</ul>
</li>
</ul>
<h2 id="semaphores-vs-spin-locks">Semaphores vs Spin Locks</h2>
<ul>
<li>프로세스는 세마포어가 사용 가능해질 때까지 잠든다
<ul>
<li>적합한 락은 오랜시간동안 잡고 있을 것이다 (스핀락은 CPU 사이클을 낭비)</li>
</ul>
</li>
<li>짧은 시간동안 잡고있는 락은 적합하지 않다
<ul>
<li>대기큐를 유지 + 프로세스 스케줄링 + 깨어나는 것의 오버헤드가 총 잠금 시간보다 클 수 있다.</li>
</ul>
</li>
<li>프로세스가 세마포어를 획득하려고 하면 잠들 수도 있다 (획득 실패시)
<ul>
<li><strong>Interrupt context에서 사용 불가능</strong>
<ul>
<li>interrupt handler</li>
<li>softirq</li>
<li>tasklet</li>
</ul>
</li>
<li><strong>Process context에서만 세마포어 사용 가능</strong>
<ul>
<li>system call</li>
<li>workqueue</li>
</ul>
</li>
</ul>
</li>
<li>락과 달리 세마포어를 잡고있는 것은 커널 선점을 비활성화 하지 않는다
<ul>
<li>세마포어를 잡고있는 프로세스는 선점될 수 있다</li>
<li>스케줄링 지연시간에 영향을 주지 않는다</li>
</ul>
</li>
<li>counting semaphore는 동시에 여러개 진입 가능
<ul>
<li>spin lock은 락당 1개만 허용</li>
</ul>
</li>
</ul>
<h2 id="completions">Completions</h2>
<ul>
<li>Completion 변수는 세마포어의 특별한 경우
<ul>
<li>두 커널 작업을 동기화 하는 쉬운 방법</li>
<li>멀티프로세스 시스템에서 down(), up()가 동시에 돌아갈때의 경쟁상태를 해결</li>
</ul>
</li>
</ul>
<h2 id="interrupt-disabling">Interrupt Disabling</h2>
<ul>
<li>local CPU의 인터럽트를 전부 비활성화/활성화
<ul>
<li>커널 코드가 임계영역대로 작동하는것을 보장한다</li>
<li>인터럽트를 끄면 인터럽트 핸들러가 현재 코드를 선점하지 못한다</li>
<li>인터럽트를 끄면 커널 선점도 꺼진다</li>
</ul>
</li>
<li>멀티프로세스 시스템
<ul>
<li>인터럽트를 끄는것은 다른 CPU에는 영향이 없다. 그래서 다른 프로세스의 동시 접근을 막을 수 없다</li>
<li><strong>spin lock + local 인터럽트 비활성화</strong></li>
</ul>
</li>
<li>인터럽트를 꺼도 interleaving은 발생한다
<ul>
<li>Kernel control path에서 직접 <code>schedule()</code> 호출</li>
<li><strong>커널은 인터럽트가 꺼져있는 동안 절대로 blocking 함수를 호출하면 안된다</strong>
<ul>
<li>시스템이 멈춘다</li>
<li>왜냐하면 blocking 상태를 깨워줄 인터럽트가 없으니까</li>
</ul>
</li>
</ul>
</li>
<li>인터럽트를 끄는 임계구역은 짧아야한다.
<ul>
<li>긴 임계구역은 locking을 이용해서 구현해야한다</li>
<li>인터럽트 끄는 시간이 길다 -&gt; 시스템 반응성이 떨어진다</li>
</ul>
</li>
</ul>
<h2 id="global-kernel-lock-the-big-kernel-lock">Global Kernel Lock (The Big Kernel Lock)</h2>
<ul>
<li>리눅스 2.0의 커널 모드에서는 오직 1개의 CPU만 작동한다
<ul>
<li>거의 조잡한 스핀락이었음</li>
</ul>
</li>
<li>2.2/2.4에서 개선됨
<ul>
<li>더이상 단일 스핀락에 의존하지 않는다</li>
</ul>
</li>
<li>2.6에서 big kernel lock은 옛날 코드와 VFS, 일부 filesystem 관련 코드에서만 사용
<ul>
<li>성능상의 문제로 거의 대부분 사라짐</li>
</ul>
</li>
<li>2.6.11의 경우 <code>kernel_sem</code> semaphore == big kenel lock
<ul>
<li>2.6 초반에는 스핀락으로 구현되어 있었음</li>
</ul>
</li>
<li><code>lock_kernel()</code>, <code>unlock_kernel()</code></li>
</ul>
<h2 id="synchronizing-access-to-kernel-data-structures">Synchronizing Access to Kernel Data Structures</h2>
<ul>
<li>int 1개의 공유 자료구조
<ul>
<li><code>atomic_t</code> + atomic operation</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>KCP에서 접근하는 자료구조 보호</th>
<th>Uni</th>
<th>Multi</th>
</tr>
</thead>
<tbody>
<tr>
<td>exception</td>
<td>세마포어</td>
<td></td>
</tr>
<tr>
<td>Interrupt</td>
<td>로컬 인터럽트 끄기</td>
<td>스핀락</td>
</tr>
<tr>
<td>deferrable func</td>
<td></td>
<td>x or 스핀락</td>
</tr>
<tr>
<td>exception + interrupt</td>
<td>로컬 인터럽트 끄기</td>
<td>스핀락</td>
</tr>
<tr>
<td>exception + deferrable func</td>
<td>로컬 softirq 끄기</td>
<td>스핀락</td>
</tr>
<tr>
<td>interrupt + deferrable func</td>
<td>로컬 인터럽트 끄기</td>
<td>스핀락</td>
</tr>
<tr>
<td>exception + interrupt + deferrable funnc</td>
<td>로컬 인터럽트 끄기</td>
<td>스핀락</td>
</tr>
</tbody>
</table>
<h3 id="exception에-의해-접근하는-자료구조-보호">Exception에 의해 접근하는 자료구조 보호</h3>
<ul>
<li>일반적으로 system call</li>
<li>세마포어 (UP + MP)</li>
</ul>
<h3 id="interrupt에-의해-접근하는-자료구조-보호">Interrupt에 의해 접근하는 자료구조 보호</h3>
<ul>
<li>각각의 인터럽트 핸들러는 그 자체로 직렬화 된다 -&gt; 하나의 타입의 인터럽트에 대해서는 동기화 할 필요없음</li>
<li>멀티 CPU의 경우
<ul>
<li>다른 종류의 인터럽트 동시 작동 가능</li>
<li>같은 종료우 인터럽트 동시 작동 불가능</li>
</ul>
</li>
<li>Uni-processor : 로컬 인터럽트 끄기</li>
<li>Multi-processor : 로컬 인터럽트 끄기 + 스핀락</li>
</ul>
<h3 id="deferrable-function에-의해-접근하는-자료구조-보호">deferrable function에 의해 접근하는 자료구조 보호</h3>
<ul>
<li>Uni프로세서에서는 경쟁상태 없다
<ul>
<li>모든 deferrable 함수는 CPU에서 직렬화되어 실행된다</li>
</ul>
</li>
<li>SMP의 경우 몇몇 deferrable 함수가 동시에 작동할 수 있어서 경쟁상태 존재
<ul>
<li>Softirq
<ul>
<li>스핀락</li>
<li>같은 softirq가 다른 CPU에서 동시 작동 가능</li>
</ul>
</li>
<li>한 종류의 tasklet
<ul>
<li>필요없음</li>
<li>같은 종류의 tasklet은 동시에 돌아가지 않는다</li>
</ul>
</li>
<li>여러 종류의 tasklet
<ul>
<li>스핀락</li>
<li>여러 종류의 tasklet은 다른 CPU에서 동시 작동 가능</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="etc">etc</h3>
<ul>
<li>경우의 수
<ul>
<li>Exception + Interrupt</li>
<li>Interrupt + Deferrable func</li>
<li>Exception + Interrupt + Deferrable func</li>
</ul>
</li>
<li>Uni프로세서
<ul>
<li>로컬 인터럽트 끄기</li>
</ul>
</li>
<li>SMP
<ul>
<li>로컬 인터럽트 끄기 + 스핀락</li>
</ul>
</li>
</ul>
<h2 id="synchronization-mechanisms-summary">Synchronization Mechanisms Summary</h2>
<ul>
<li>Atomic Operation</li>
<li>인터럽트 끄기
<ul>
<li>간단하지만 병렬성 낮아짐</li>
</ul>
</li>
<li>스핀락
<ul>
<li>다른 CPU로부터 보호하는데는 적절하지만 Uni프로세서에서는 불가능</li>
</ul>
</li>
<li>세마포어
<ul>
<li>다른 작업간의 적절한 동기화 방법</li>
<li>스케쥴러 실행 가능성 있음, interrupt context에서 사용 불가능</li>
</ul>
</li>
<li>일반적인 대응
<ul>
<li>Uni프로세서 : 인터럽트 끄기</li>
<li>SMP : 스핀락 + 인터럽트 끄기</li>
</ul>
</li>
</ul>

    </section>

    <ul class="articles-timeline">
      <li class="previous-article">
        
        <a href="https://libsora.so/posts/system-prog-signals/" title="Next: Signals">
          Signals
          
          <br/><small>2014년 2학기 시스템 프로그래밍 시험 공부</small>
          
        </a>
        
      </li>

      <li class="next-article">
        
        <a href="https://libsora.so/posts/system-programming-memory-addressing/" title="Previous: Memory Addressing">
          Memory Addressing
          
          <br/><small>2014년 2학기 시스템 프로그래밍 시험 공부</small>
          
        </a>
        
      </li>
    </ul>

    <section class="entry-content">
      <section class="disqus-section">
<h1 hidden>Comment</h1>
<div id="disqus_thread"></div>
<script type="text/javascript">
  var host = "libsora.so";
  if (host == window.location.host) {
    var disqus_shortname = 'libsora';
    var disqus_identifier = 'http://libsora.so\/posts\/system-prog-kernel-synchronization\/';

    (function() {
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  } else {
    console.log("skip disqus");
  }
</script>
<noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

    </section>
  </article>
</div>

<footer class="footer">
  <ul class="nav-link-list">
    
    
    
    <li>
      
      <a href="//twitter.com/if1live" title="Twitter"><i class="fa fa-twitter"> </i></a>
    </li>
    
    
    
    <li>
      
      <a href="//github.com/if1live" title="GitHub"><i class="fa fa-github"> </i></a>
    </li>
    
    
    
    <li>
      
      <a href="//bitbucket.org/if1live" title="BitBucket"><i class="fa fa-bitbucket"> </i></a>
    </li>
    

    <li>
      
      <a href="https://libsora.so/index.xml"><i class="fa fa-rss"> </i></a>
    </li>

    
  </ul>

  <p>
    <a href="//gohugo.io/" title="Hugo">Hugo</a> |
    
    <a href="//twitter.com/if1live/" title="@if1live">@if1live</a>
    
  </p>
</footer>

<script src="/js/common.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/prism.min.js"
  integrity="sha512-9+422Bs3A87UkWfp+qV80Nfv9arhbCXKY1rxrF2seorI36mIIstMiuBfyKLF1yH1nnzQkEWq2xrzT4XU3Z+vrA=="
  crossorigin="anonymous"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/plugins/line-numbers/prism-line-numbers.min.js"
  integrity="sha512-1oLZvExT5RaW4q2GgvRPf+XzVVGmsKirfZBRN7aifdOpvZ1L9idEncfMFlfHiQNGBA+Sev+alscSAT/xQ0rwXA=="
  crossorigin="anonymous"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-clike.min.js"
  integrity="sha512-/WJ9ZNER39LEXW4XzFoMR6ct++/HT++A71MDW2gBbUJExj8hFRtde5Q5QzcHyBMxU97VeH1wEHGBRtNuGJpV4w=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-c.min.js"
  integrity="sha512-TO7UeOg1N67oP7UU2OzrOm0oZrTz2TXGNRtkf/x+d9Pt5O8cb5jeSRcryiXqW/Nd25VEc8Qqtu8Dx1EVV7AJLQ=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-cpp.min.js"
  integrity="sha512-dzF2RO45FHCMPdWDQ3I7Cn9xPvCM8x8T4ODz+kSPQl5CAuIMy6Ekb2i2DAjLEpG/V/DL9f/O7+9E/HZQQx89IA=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-typescript.min.js"
  integrity="sha512-5KnWNKu6jz8OE4nIBndz3PZ4O3RGqcPNcsyEFZkx3F5N8liSwc3bCe4qPOa/a3+e4CxVl0izHMXeZ0Z4yk7LTA=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-python.min.js"
  integrity="sha512-EXseTM1JV8e3AonU5PfOUmzbPkUTRm4c4hVxv206gVeWZE/FwzSQBNWrUBaHsN3Idq9k76BEjUlXpluX1UFx6Q=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-javascript.min.js"
  integrity="sha512-UN3RxBb1KfsWQUMNl19SU/JPer3v8jTBpfGyQaBEuaVjP5q0Gz9ihj8MiHEUZYnc1krYRm5imVebjq1egsSaKA=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-java.min.js"
  integrity="sha512-p2vAaPEsPvlIESCpoEI5IyzZowfdVZ2O39PsrOrkuTQl+AjD57T4L/Wxv5S8WCToLou0twQZaWO+tt660Rqb6Q=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-csharp.min.js"
  integrity="sha512-qvSIQfI/qEeMC1E1LMSPCsDl8vFzl0rkBfF6dDcnMJxQT+8M2WjSyDGqHQzZa+RChv3jkdKnZAo99BcAbGsnQg=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-bash.min.js"
  integrity="sha512-CILPDr/8BlkkElCeI+f2yMu0fzgwWqpQ0Cdr0busFfySJJ4SoCRivbT6+Z+SWPkjWwBil9NO0tHd6NSfpwiQaA=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-ruby.min.js"
  integrity="sha512-Wgi0cnFpl5EY8xLe1RO+uTsot86wzAbW/BIoqZopPU+8YW79VDqQE9qTe1R+1uhxLsPBHE+nYwACS+eTsE5GtQ=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-go.min.js"
  integrity="sha512-hVtwzUDz/n7RqQmiQ7xYAJCTTJe5C52Ung+4Kpz2fPRq7nq2h5gHHQe2HRy7f1Tj3OUVgTO5WRx7XuwT624C9Q=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-less.min.js"
  integrity="sha512-REVnwsprLWmQbtt0WjkS59nMvtKE0olIjUx+N/k3Gqa5WhmrZ7o0ahGhKYnIK6W2+ITg4cQ2UqZkka4RaZSM9Q=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-scss.min.js"
  integrity="sha512-rAb9BrnkhMpxN7NoOM7WwPa3phfCMMUZw568Tyzlj9frNsdUUeltfCTATD6ccnVLtnERR+ZXS85Ybs7wo9IiTQ=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-css.min.js"
  integrity="sha512-zDjwO/e5eVa5WfYra8CE827RFyA/nqhp8y4da+geEpAqpCnmfAHopCNobQ9sJeLBMQY0OLB+hT+k6bbb0FhdYQ=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-json.min.js"
  integrity="sha512-IC7rV8RslChgByOdUFC6ePqOGn+OwJhnKC3S5AezM8DAiOdGhJMwgsIvBChsa2yuxxoPbH2+W/kjNUM1cc+jUQ=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-yaml.min.js"
  integrity="sha512-j9sRnEoasdNn9OSwsCxjrQi1H55NqBFDJ+oe7me3sIfvDLeTyzvnZXf0eJqL5CvX6rswU2Sld9PnTVQ0Xy2CFQ=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-batch.min.js"
  integrity="sha512-YzSVmlznJS4QEi5/tSS9iZ/tVFGdQSKO/F2jsofNH+5PifywJfsOtOZaia+URhumCMdXTTG2UZQ4vtBHWids+Q=="
  crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.22.0/components/prism-lisp.min.js"
  integrity="sha512-3c6jwEnUKsrvucb8b9xdDJw13zOdbeP83PvlSKeoTCCWGacG03MUWHCcBev2NKHA+w8IAWZsGXBcNMaIH/VWYA=="
  crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.3/mermaid.min.js"
  integrity="sha512-+TNmhaRJf3jyYHTpzEq/5I6b+aGyhzWb21mGdHAjxSGSYwxN9Grug3Y3B9qVxWfKKY8MscE/6mr9walWvFLFvQ=="
  crossorigin="anonymous"></script>

<script>
  mermaid.initialize({ startOnLoad: true });

  (function () {
    const elems = document.querySelectorAll('code.language-mermaid');
    for (let i = 0; i < elems.length; i++) {
      const id = `mermaid-${i}`;
      const elem = elems[i];
      const source = elem.innerText;
      const cb = (svg) => {
        const div = document.createElement('div');
        div.innerHTML = svg;
        elem.parentElement.replaceWith(div);
      };
      mermaid.render(id, source, cb);
    }
  })();
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js"
  integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg=="
  crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js"
  integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg=="
  crossorigin="anonymous"></script>

<script>
  renderMathInElement(document.body,
    {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
      ]
    }
  );

  var inlineMathArray = document.querySelectorAll("script[type='math/tex']");
  for (var i = 0; i < inlineMathArray.length; i++) {
    var inlineMath = inlineMathArray[i];
    var tex = inlineMath.innerText || inlineMath.textContent;
    var replaced = document.createElement("span");
    replaced.innerHTML = katex.renderToString(tex, { displayMode: false });
    inlineMath.parentNode.replaceChild(replaced, inlineMath);
  }

  var displayMathArray = document.querySelectorAll("script[type='math/tex; mode=display']");
  for (var i = 0; i < displayMathArray.length; i++) {
    var displayMath = displayMathArray[i];
    var tex = displayMath.innerHTML;
    var replaced = document.createElement("span");
    replaced.innerHTML = katex.renderToString(tex.replace(/%.*/g, ''), { displayMode: true });
    displayMath.parentNode.replaceChild(replaced, displayMath);
  }
</script>


<script>
  var host = "libsora.so";
  if (host == window.location.host) {
    window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
    ga('create','UA-37862172-2','auto');ga('send','pageview')
  } else {
    console.log("skip google analytics");
  }
</script>
<script src="https://www.google-analytics.com/analytics.js" async defer></script>


</body>
</html>

